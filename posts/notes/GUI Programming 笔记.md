---
title: 'GUI Programming 笔记'
date: '2022-01-20'
abstract: '读书笔记之 GUI Programming'
---


## GUI Programming 笔记

link: [15.1. Graphical User Interfaces](https://runestone.academy/ns/books/published//thinkcspy/GUIandEventDrivenProgramming/01_intro_gui.html)

### 理念：GUI 编程即事件驱动编程

- graphical user interface (图形用户界面) 与 command line interface (命令行界面) 相对。GUI 程序中的任务执行顺序由用户控制，因此程序需时时跟踪用户动作，按照顺序处理任务、反馈结果。此种编程风格叫`event driven programming`。所有的 GUI 程序皆为事件驱动程序。

#### GUI 程序的结构：
	- 创建一个窗口(window, 这里的 window指操作系统中的窗口)，放上用于用户交互的图标、按钮、小组件；
	- 定义函数，用它们来处理`用户事件`；
	- 将用户事件与相应的函数绑定；
	- 启动一个 `event-loop`来处理`用户事件`，当一个`用户事件`发生时，`event-loop`会调用和它绑定的函数。

- 操作系统的角色：
	- 操作系统控制 window 的创建与操控；
	- 操作系统控制电脑的输入设备，如鼠标、键盘、触屏，因而在用户事件发生后，操作系统捕获事件，将这些事件依次发给你的程序，由程序的 `event-loop` 处理这些事件。

```python
while True:
  # Get the next event from the operating system
  event = get_next_event()

  # Get the function that is assigned to handle this event
  a_function_to_handle_the_event = event-handlers[event]

  # If a function has been assigned to handle this event, call the function
  if a_function_to_handle_the_event:
    a_function_to_handle_the_event()  # Call the event-handler function

  # Stop processing events if the user gives a command to stop the application
  if window_needs_to_close:
    break  # out of the event-loop
```

程序员不必实现一个`event-loop`，`event-loop`已经在那里写好了，你要做的是将你的事件处理函数(`event-handler` 、`callback function`)绑定要相应的事件上。

#### 创建 GUI 程序的一般步骤：
	1. 创建 widgets(python 中对页面中的部件的称呼，组件) 的实例；
	2. 确定 组件之间的布局 layout；
	3. 创建能够响应用户事件的函数；
	4. 将函数与特定事件关联
	5. 启动一个 GUI `event-loop`

#### 使用`Tkinter`进行 GUI 编程

第一步是创建窗口， 窗口是一个 `Tk` 对象：
```python
app_window = tk.Tk()
```

窗口用来承载其他部件，部件通过层级进行组织，像是 egret 的 ObjectContainer 一样，所有的显示对象需要加到显示对象容器中，才能显示出来。

Tkinter 中的 widget 需要在它的父级 widget 中设置大小、位置，才能显示到窗口中。A widget will not be visible in a window until you assign it a size and location within it’s parent widget.

Widgets 被组织成层级组织： Frame 是父级，是容器，Widgets 是子级，是容器中的内容。
Widgets are always organized as a hierarchy, where the main application window is the root of the hierarchy. Typically, the child widgets of an application window are a combination of “frames”. The “frames” hold other widgets. A “frame” will not be visible until it is assigned a size and location using a layout manager. 

![../_images/Grouping_examples.png](https://runestone.academy/ns/books/published//thinkcspy/_images/Grouping_examples.png)

For the Frame and LabelFrame groups, the frame is the “parent” of the widgets displayed inside the frame. That is, when the buttons were created, the frame was the first parameter to the tk.Button() function.

For the PanedWindow and Notebook groups, you use an .add(widget) function to add your widgets to the group. You are still creating a hierarchy of widgets, but the syntax is different.

有两种方式对 Tkinter 中的 Widgets 关联事件：
	1. 有的组件预定义了事件，给这些组件的 `command` 属性传入一个函数的引用即可
	2. 处理 low-level 事件时，要用 event binding 的方式

- 操作系统将事件对象发给谁？
获得 Focus 的窗口。操作系统控制键盘、鼠标等输入设备，当用户用这些设备进行交互时，操作系统创建 `event object` 捕获事件的信息，问题是，同一时间往往有很多进程在执行，操作系统捕获`event object` 后发给哪个进程？答案是发给 `active window`，只有出于活跃状态的窗口才会获得系统的 foucus，接收到事件对象。

- 处于聚焦状态的窗口获得很多 low-level 的事件如何处理？
同一时间会有很多 low-level 的事件（如鼠标移动事件、点击事件）发给焦点窗口，它怎么处理？回答是，除非你指定了哪个特定事件要发给哪个函数，否则都会被忽略。The task of associating a specific event handler function with a specific “low level” event is called binding.

举例，当你想对鼠标移过按钮的事件做些什么事时，把 `<Enter>` 事件绑定到相应的函数上:
```python
def process_event(event):
  print("The process_event function was called.")

my_button = tk.Button(application_window, text="Example")
my_button.bind("<Enter>", process_event)
```

事件即一个需要处理的行为发生了，事件由用户的交互动作发起，也可以由程序产生。GUI 程序中，所有的处理是响应事件的处理。（GUI 程序本来就是为了用户交互，如果没有任何交互，即便它一直跑着，不会产生任何事件，自然也不会有处理，它就是空跑）
An event represents an action that needs to be processed. Events are caused by a user when they click in a window or type on the keyboard. Events can also be generated by software, such as a request to redraw the application’s window after changes have been made. In a GUI program, **all** processing is done by responding to events.

产生事情时会相应创建事件对象，事件对象会作为参数传给 event handler ，事件对象有常用的属性。

有的事件如果迟迟处理不完，会被其他事件挤掉。
Events can’t be processed unless the application’s GUI event-loop is running. If an individual event handler takes a long time to process an event, other events will get “queued up” waiting for a chance to be processed. It is considered bad GUI programming for any event handler to take up too much processing time. An event handler should do as little processing as possible to accomplish its intended task and then quit. This returns control of the application back to the event loop.

### 实务：用 MVC 的结构组织 GUI 程序代码

#### 用 Python 类来组织 GUI 程序

例子：
```python
import tkinter as tk
from tkinter import ttk

def main():
    # Create the entire GUI program
    program = CounterProgram()

    # Start the GUI event loop
    program.window.mainloop()

class CounterProgram:

    def __init__(self):
        self.window = tk.Tk()
        self.my_counter = None  # All attributes should be initialize in init
        self.create_widgets()

    def create_widgets(self):
        self.my_counter = ttk.Label(self.window, text="0")
        self.my_counter.grid(row=0, column=0)

        increment_button = ttk.Button(self.window, text="Add 1 to counter")
        increment_button.grid(row=1, column=0)
        increment_button['command'] = self.increment_counter

        quit_button = ttk.Button(self.window, text="Quit")
        quit_button.grid(row=2, column=0)
        quit_button['command'] = self.window.destroy

    def increment_counter(self):
        self.my_counter['text'] = str(int(self.my_counter['text']) + 1)

if __name__ == "__main__":
    main()
```
Notice the following about this design:

- The application’s window is created in the constructor (__init__) of the CounterProgram class and then the interface widgets are created by a call to `create_widgets`.

- The event handler, `increment_counter` can access the label `self.my_counter` using the object’s attributes.

- The code creates an instance of the class `CounterProgram` and starts the GUI event-loop.

### 开发 GUI 程序的建议过程：渐进增加

This discussion will take you through an `incremental development` cycle that creates a program in well-defined stages. While you might read a finished computer program from “top to bottom,” that is not how it was developed. For a typical GUI program development, you are encouraged to go through these stages:

1. Using scratch paper, physically draw a rough sketch of your user interface.

2. Create the basic structure of your program and create the major frames that will hold the widgets needed for your program’s interface.（添加外面的框框） Give the frames an initial size and color so that you can visually see them, given that there are no widgets inside of them to determine their size.

3. Incrementally add all of the widgets you need for your program and size and position them appropriately.（在框里逐步加上组件）

4. Create your callback functions, stub them out, and assign them to appropriate events. Verify that the events are executing the correct functions.

5. Incrementally implement the functionality needed for each callback function.

**打地鼠游戏的例子**
一步步展示了如何展开渐进开发。

https://runestone.academy/ns/books/published//thinkcspy/GUIandEventDrivenProgramming/11_gui_program_example.html

### 使用 MVC 架构来管理 GUI 程序的复杂度

**Model**：model 指程序运行过程中需要记录下来的数据，或者说程序的 state 状态。这与程序的业务逻辑紧密相关。如一个 简单的`counter`，它的 model 就是一个保存 counter 计数的变量，如一个打地鼠游戏，我们想要记录用户打中的次数与 miss 的次数，那么 model 包括打中次数、miss 次数的变量计数。

**Controller**：The controller needs to define callback functions for these events and register the appropriate event with the appropriate callback. Therefore, the controller needs access to the widgets in the view object

**View**：搭建所有可视的组件

三者的关系大致是：
`controller (input) --> model (processing) --> view (output)`

From the perspective of a GUI program, this means that the callback functions, which are called when a user causes events, are the controller（controller接管所有输入并触发回调函数）, the model should perform all of the application logic（model 处理所有应用逻辑）, and the building and modification of the GUI widgets composes the view.（View 构建与修改 GUI 的组件）
